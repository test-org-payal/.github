name: Add PR Workflow to All Repos

on:
  workflow_dispatch:

jobs:
  add-workflow:
    runs-on: ubuntu-latest
    steps:
      - name: Add workflow to all repos
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.TOKEN }}
          script: |
            const org = 'test-org-payal';
            const skipRepos = ['.github'];
            
            // Complete PR workflow with auto-merge, field updates, and status tracking
            const workflowContent = String.raw`name: Add PR to Project and Auto-Merge

            on:
              pull_request:
                types: [opened, edited, reopened, synchronize, closed]
                branches:
                  - main
                  - master

            jobs:
              manage-pr:
                runs-on: ubuntu-latest
                steps:
                  - name: Manage PR in Project
                    uses: actions/github-script@v7
                    with:
                      github-token: $` + `{{ secrets.TOKEN }}
                      script: |
                        const pr = context.payload.pull_request;
                        if (!pr) { 
                          console.log('No PR context'); 
                          return; 
                        }
                        
                        const action = context.payload.action;
                        console.log('Action: ' + action);
                        console.log('PR #' + pr.number + ': ' + pr.title);
                        
                        const org = 'test-org-payal';
                        const projectNumber = 2;
                        
                        console.log('\\n--- Getting Project Info ---');
                        const projectQuery = await github.graphql(\`
                          query($` + `org: String!, $` + `projectNumber: Int!) {
                            organization(login: $` + `org) {
                              projectV2(number: $` + `projectNumber) {
                                id
                                fields(first: 20) {
                                  nodes {
                                    ... on ProjectV2Field {
                                      id
                                      name
                                    }
                                    ... on ProjectV2SingleSelectField {
                                      id
                                      name
                                      options {
                                        id
                                        name
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }\`, { org: org, projectNumber: projectNumber });
                        
                        const project = projectQuery.organization.projectV2;
                        const projectId = project.id;
                        const fields = project.fields.nodes;
                        
                        console.log('Project ID: ' + projectId);
                        console.log('Fields found: ' + fields.length);
                        
                        const releaseNotesField = fields.find(f => f.name === 'Release Notes');
                        const deployNotesField = fields.find(f => f.name === 'Deployment Notes');
                        const dependenciesField = fields.find(f => f.name === 'Dependencies');
                        const mergeStatusField = fields.find(f => f.name === 'Merge Status');
                        
                        console.log('\\n--- Adding PR to Project ---');
                        let itemId = null;
                        
                        try {
                          const addResult = await github.graphql(\`
                            mutation($` + `projectId: ID!, $` + `contentId: ID!) {
                              addProjectV2ItemById(input: {projectId: $` + `projectId, contentId: $` + `contentId}) {
                                item { id }
                              }
                            }\`, { projectId: projectId, contentId: pr.node_id });
                          
                          itemId = addResult.addProjectV2ItemById.item.id;
                          console.log('‚úÖ PR added - Item ID: ' + itemId);
                        } catch (e) {
                          console.log('Error adding PR: ' + e.message);
                          
                          const findQuery = await github.graphql(\`
                            query($` + `projectId: ID!) {
                              node(id: $` + `projectId) {
                                ... on ProjectV2 {
                                  items(first: 100) {
                                    nodes {
                                      id
                                      content {
                                        ... on PullRequest {
                                          number
                                          repository { name }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }\`, { projectId: projectId });
                          
                          const existingItem = findQuery.node.items.nodes.find(
                            item => item.content?.number === pr.number && 
                                    item.content?.repository?.name === context.repo.repo
                          );
                          
                          if (existingItem) {
                            itemId = existingItem.id;
                            console.log('‚úÖ Found existing item: ' + itemId);
                          } else {
                            console.log('‚ùå Could not add or find PR in project');
                            return;
                          }
                        }
                        
                        console.log('\\n--- Extracting PR Content ---');
                        const body = pr.body || '';
                        
                        const releaseMatch = body.match(/## Release Notes\\s*\\n+([\\s\\S]*?)(?=\\n##|$)/i);
                        const releaseNotes = releaseMatch ? releaseMatch[1].trim() : '';
                        
                        const deployMatch = body.match(/## Deployment Notes\\s*\\n+([\\s\\S]*?)(?=\\n##|$)/i);
                        const deployNotes = deployMatch ? deployMatch[1].trim() : '';
                        
                        const dependencyMatch = body.match(/## Dependencies\\s*\\n+([\\s\\S]*?)(?=\\n##|$)/i);
                        const dependencies = dependencyMatch ? dependencyMatch[1].trim() : '';
                        
                        console.log('Release Notes: ' + (releaseNotes ? 'Found' : 'Empty'));
                        console.log('Deployment Notes: ' + (deployNotes ? 'Found' : 'Empty'));
                        console.log('Dependencies: ' + (dependencies ? 'Found' : 'Empty'));
                        
                        const mergeStatus = pr.merged ? 'Merged' : 'Not Merged';
                        console.log('Merge Status: ' + mergeStatus);
                        
                        console.log('\\n--- Updating Fields ---');
                        
                        if (releaseNotes && releaseNotesField) {
                          try {
                            await github.graphql(\`
                              mutation($` + `projectId: ID!, $` + `itemId: ID!, $` + `fieldId: ID!, $` + `value: String!) {
                                updateProjectV2ItemFieldValue(input: {
                                  projectId: $` + `projectId, itemId: $` + `itemId, fieldId: $` + `fieldId,
                                  value: { text: $` + `value }
                                }) { projectV2Item { id } }
                              }\`, {
                                projectId: projectId, itemId: itemId,
                                fieldId: releaseNotesField.id,
                                value: releaseNotes.substring(0, 1024)
                              });
                            console.log('‚úÖ Release Notes updated');
                          } catch (e) {
                            console.log('‚ö†Ô∏è Release Notes update failed: ' + e.message);
                          }
                        }
                        
                        if (deployNotes && deployNotesField) {
                          try {
                            await github.graphql(\`
                              mutation($` + `projectId: ID!, $` + `itemId: ID!, $` + `fieldId: ID!, $` + `value: String!) {
                                updateProjectV2ItemFieldValue(input: {
                                  projectId: $` + `projectId, itemId: $` + `itemId, fieldId: $` + `fieldId,
                                  value: { text: $` + `value }
                                }) { projectV2Item { id } }
                              }\`, {
                                projectId: projectId, itemId: itemId,
                                fieldId: deployNotesField.id,
                                value: deployNotes.substring(0, 1024)
                              });
                            console.log('‚úÖ Deployment Notes updated');
                          } catch (e) {
                            console.log('‚ö†Ô∏è Deployment Notes update failed: ' + e.message);
                          }
                        }
                        
                        if (dependencies && dependenciesField) {
                          try {
                            await github.graphql(\`
                              mutation($` + `projectId: ID!, $` + `itemId: ID!, $` + `fieldId: ID!, $` + `value: String!) {
                                updateProjectV2ItemFieldValue(input: {
                                  projectId: $` + `projectId, itemId: $` + `itemId, fieldId: $` + `fieldId,
                                  value: { text: $` + `value }
                                }) { projectV2Item { id } }
                              }\`, {
                                projectId: projectId, itemId: itemId,
                                fieldId: dependenciesField.id,
                                value: dependencies.substring(0, 1024)
                              });
                            console.log('‚úÖ Dependencies updated');
                          } catch (e) {
                            console.log('‚ö†Ô∏è Dependencies update failed: ' + e.message);
                          }
                        }
                        
                        if (mergeStatusField) {
                          try {
                            const option = mergeStatusField.options?.find(o => o.name === mergeStatus);
                            if (option) {
                              await github.graphql(\`
                                mutation($` + `projectId: ID!, $` + `itemId: ID!, $` + `fieldId: ID!, $` + `optionId: String!) {
                                  updateProjectV2ItemFieldValue(input: {
                                    projectId: $` + `projectId, itemId: $` + `itemId, fieldId: $` + `fieldId,
                                    value: { singleSelectOptionId: $` + `optionId }
                                  }) { projectV2Item { id } }
                                }\`, {
                                  projectId: projectId, itemId: itemId,
                                  fieldId: mergeStatusField.id,
                                  optionId: option.id
                                });
                              console.log('‚úÖ Merge Status updated: ' + mergeStatus);
                            } else {
                              console.log('‚ö†Ô∏è Merge Status option not found: ' + mergeStatus);
                            }
                          } catch (e) {
                            console.log('‚ö†Ô∏è Merge Status update failed: ' + e.message);
                          }
                        }
                        
                        console.log('\\n--- Checking Merge Conditions ---');
                        const hasReleaseNotes = releaseNotes && !releaseNotes.startsWith('<!--') && releaseNotes.length > 0;
                        const hasDeployNotes = deployNotes && !deployNotes.startsWith('<!--') && deployNotes.length > 0;
                        
                        if (!hasReleaseNotes || !hasDeployNotes) {
                          console.log('‚ùå Cannot merge - missing required fields');
                          const missing = [];
                          if (!hasReleaseNotes) missing.push('‚ùå Release notes');
                          if (!hasDeployNotes) missing.push('‚ùå Deployment notes');
                          
                          const commentBody = '## ‚è≥ Merge Checklist\\n\\n**Required:**\\n' + missing.join('\\n') + '\\n\\nPlease complete all required items.';
                          
                          const comments = await github.rest.issues.listComments({
                            owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number
                          });
                          const botComment = comments.data.find(c => c.user.type === 'Bot' && c.body.includes('Merge Checklist'));
                          
                          if (botComment) {
                            await github.rest.issues.updateComment({
                              owner: context.repo.owner, repo: context.repo.repo,
                              comment_id: botComment.id, body: commentBody
                            });
                          } else {
                            await github.rest.issues.createComment({
                              owner: context.repo.owner, repo: context.repo.repo,
                              issue_number: pr.number, body: commentBody
                            });
                          }
                          return;
                        }
                        
                        console.log('\\n--- Auto-Merging ---');
                        try {
                          let commitMessage = 'Release Notes:\\n' + releaseNotes + '\\n\\nDeployment Notes:\\n' + deployNotes;
                          if (dependencies) commitMessage += '\\n\\nDependencies:\\n' + dependencies;
                          
                          await github.rest.pulls.merge({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            pull_number: pr.number,
                            merge_method: 'squash',
                            commit_title: pr.title + ' (#' + pr.number + ')',
                            commit_message: commitMessage
                          });
                          
                          console.log('‚úÖ PR merged successfully!');
                          
                          await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: pr.number,
                            body: '## ‚úÖ Auto-Merged!\\n\\nAll checks passed.'
                          });
                        } catch (e) {
                          console.error('‚ùå Merge failed: ' + e.message);
                          await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: pr.number,
                            body: '‚ùå Auto-merge failed: ' + e.message
                          });
                        }
            `;

            // Get all repos
            const repos = await github.paginate(github.rest.repos.listForOrg, {
              org: org,
              per_page: 100
            });
            
            console.log(`Found ${repos.length} repositories in ${org}`);
            console.log('---\n');
            
            let successCount = 0;
            let failCount = 0;
            let skippedCount = 0;
            
            for (const repo of repos) {
              if (skipRepos.includes(repo.name)) {
                console.log(`‚è≠Ô∏è  Skipping: ${repo.name}`);
                skippedCount++;
                continue;
              }
              
              console.log(`Processing: ${repo.name}`);
              
              const path = '.github/workflows/pr-to-project.yml';
              
              let sha = null;
              try {
                const existing = await github.rest.repos.getContent({
                  owner: org,
                  repo: repo.name,
                  path: path,
                  ref: repo.default_branch
                });
                sha = existing.data.sha;
                console.log(`  Updating existing workflow...`);
              } catch (e) {
                if (e.status === 404) {
                  console.log(`  Creating new workflow...`);
                } else {
                  console.log(`  Warning: ${e.message}`);
                }
              }
              
              try {
                const params = {
                  owner: org,
                  repo: repo.name,
                  path: path,
                  message: sha ? 'Update: PR workflow [skip ci]' : 'Add: PR workflow [skip ci]',
                  content: Buffer.from(workflowContent).toString('base64'),
                  branch: repo.default_branch
                };
                
                if (sha) {
                  params.sha = sha;
                }
                
                await github.rest.repos.createOrUpdateFileContents(params);
                console.log(`  ‚úÖ Success\n`);
                successCount++;
              } catch (e) {
                console.log(`  ‚ùå Failed: ${e.message}\n`);
                failCount++;
              }
            }
            
            console.log('---');
            console.log('\nüìä Summary:');
            console.log(`   Total repos: ${repos.length}`);
            console.log(`   ‚è≠Ô∏è  Skipped: ${skippedCount}`);
            console.log(`   ‚úÖ Success: ${successCount}`);
            console.log(`   ‚ùå Failed: ${failCount}`);
            console.log('\n‚úÖ Done!');
