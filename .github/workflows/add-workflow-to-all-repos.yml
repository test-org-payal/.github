name: Add PR Workflow to All Repos

on:
  workflow_dispatch:

jobs:
  add-workflow:
    runs-on: ubuntu-latest
    steps:
      - name: Add workflow to all repos
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.TOKEN }}
          script: |
            const org = 'test-org-payal';
            const skipRepos = ['.github'];
            
            // Build workflow content with proper escaping
            const workflowContent = `name: Add PR to Project and Auto-Merge

            on:
              pull_request:
                types: [opened, edited, reopened, synchronize, closed]
                branches:
                  - main
                  - master

            jobs:
              manage-pr:
                runs-on: ubuntu-latest
                steps:
                  - name: Manage PR in Project
                    uses: actions/github-script@v7
                    with:
                      github-token: $` + `{{ secrets.TOKEN }}
                      script: |
                        const pr = context.payload.pull_request;
                        if (!pr) { console.log('No PR context'); return; }
                        
                        const action = context.payload.action;
                        console.log('Action: ' + action);
                        console.log('PR #' + pr.number + ': ' + pr.title);
                        
                        const org = 'test-org-payal';
                        const projectNumber = 2;
                        
                        console.log('\\\\n--- Getting Project Info ---');
                        const projectQuery = await github.graphql(\`` + `
                          query($` + `org: String!, $` + `projectNumber: Int!) {
                            organization(login: $` + `org) {
                              projectV2(number: $` + `projectNumber) {
                                id
                                fields(first: 20) {
                                  nodes {
                                    ... on ProjectV2Field { id name }
                                    ... on ProjectV2SingleSelectField {
                                      id name
                                      options { id name }
                                    }
                                  }
                                }
                              }
                            }
                          }\`` + `, { org: org, projectNumber: projectNumber });
                        
                        const project = projectQuery.organization.projectV2;
                        const projectId = project.id;
                        const fields = project.fields.nodes;
                        
                        console.log('Project ID: ' + projectId);
                        
                        const releaseNotesField = fields.find(f => f.name === 'Release Notes');
                        const deployNotesField = fields.find(f => f.name === 'Deployment Notes');
                        const dependenciesField = fields.find(f => f.name === 'Dependencies');
                        const mergeStatusField = fields.find(f => f.name === 'Merge Status');
                        
                        console.log('\\\\n--- Adding PR to Project ---');
                        let itemId = null;
                        
                        try {
                          const addResult = await github.graphql(\`` + `
                            mutation($` + `projectId: ID!, $` + `contentId: ID!) {
                              addProjectV2ItemById(input: {projectId: $` + `projectId, contentId: $` + `contentId}) {
                                item { id }
                              }
                            }\`` + `, { projectId: projectId, contentId: pr.node_id });
                          itemId = addResult.addProjectV2ItemById.item.id;
                          console.log('‚úÖ PR added - Item ID: ' + itemId);
                        } catch (e) {
                          console.log('Error: ' + e.message);
                          const findQuery = await github.graphql(\`` + `
                            query($` + `projectId: ID!) {
                              node(id: $` + `projectId) {
                                ... on ProjectV2 {
                                  items(first: 100) {
                                    nodes {
                                      id
                                      content {
                                        ... on PullRequest { number repository { name } }
                                      }
                                    }
                                  }
                                }
                              }
                            }\`` + `, { projectId: projectId });
                          const existingItem = findQuery.node.items.nodes.find(
                            item => item.content?.number === pr.number && item.content?.repository?.name === context.repo.repo
                          );
                          if (existingItem) {
                            itemId = existingItem.id;
                            console.log('‚úÖ Found existing: ' + itemId);
                          } else {
                            console.log('‚ùå Could not add PR');
                            return;
                          }
                        }
                        
                        console.log('\\\\n--- Extracting Content ---');
                        const body = pr.body || '';
                        const releaseMatch = body.match(/## Release Notes\\s*\\n+([\\s\\S]*?)(?=\\n##|$)/i);
                        const releaseNotes = releaseMatch ? releaseMatch[1].trim() : '';
                        const deployMatch = body.match(/## Deployment Notes\\s*\\n+([\\s\\S]*?)(?=\\n##|$)/i);
                        const deployNotes = deployMatch ? deployMatch[1].trim() : '';
                        const dependencyMatch = body.match(/## Dependencies\\s*\\n+([\\s\\S]*?)(?=\\n##|$)/i);
                        const dependencies = dependencyMatch ? dependencyMatch[1].trim() : '';
                        const mergeStatus = pr.merged ? 'Merged' : 'Not Merged';
                        
                        console.log('Release Notes: ' + (releaseNotes ? 'Found' : 'Empty'));
                        console.log('Deployment Notes: ' + (deployNotes ? 'Found' : 'Empty'));
                        console.log('Merge Status: ' + mergeStatus);
                        
                        console.log('\\\\n--- Updating Fields ---');
                        if (releaseNotes && releaseNotesField) {
                          try {
                            await github.graphql(\`` + `
                              mutation($` + `projectId: ID!, $` + `itemId: ID!, $` + `fieldId: ID!, $` + `value: String!) {
                                updateProjectV2ItemFieldValue(input: {
                                  projectId: $` + `projectId, itemId: $` + `itemId, fieldId: $` + `fieldId, value: { text: $` + `value }
                                }) { projectV2Item { id } }
                              }\`` + `, { projectId: projectId, itemId: itemId, fieldId: releaseNotesField.id, value: releaseNotes.substring(0, 1024) });
                            console.log('‚úÖ Release Notes updated');
                          } catch (e) { console.log('‚ö†Ô∏è Release Notes failed'); }
                        }
                        
                        if (deployNotes && deployNotesField) {
                          try {
                            await github.graphql(\`` + `
                              mutation($` + `projectId: ID!, $` + `itemId: ID!, $` + `fieldId: ID!, $` + `value: String!) {
                                updateProjectV2ItemFieldValue(input: {
                                  projectId: $` + `projectId, itemId: $` + `itemId, fieldId: $` + `fieldId, value: { text: $` + `value }
                                }) { projectV2Item { id } }
                              }\`` + `, { projectId: projectId, itemId: itemId, fieldId: deployNotesField.id, value: deployNotes.substring(0, 1024) });
                            console.log('‚úÖ Deployment Notes updated');
                          } catch (e) { console.log('‚ö†Ô∏è Deployment Notes failed'); }
                        }
                        
                        if (dependencies && dependenciesField) {
                          try {
                            await github.graphql(\`` + `
                              mutation($` + `projectId: ID!, $` + `itemId: ID!, $` + `fieldId: ID!, $` + `value: String!) {
                                updateProjectV2ItemFieldValue(input: {
                                  projectId: $` + `projectId, itemId: $` + `itemId, fieldId: $` + `fieldId, value: { text: $` + `value }
                                }) { projectV2Item { id } }
                              }\`` + `, { projectId: projectId, itemId: itemId, fieldId: dependenciesField.id, value: dependencies.substring(0, 1024) });
                            console.log('‚úÖ Dependencies updated');
                          } catch (e) { console.log('‚ö†Ô∏è Dependencies failed'); }
                        }
                        
                        if (mergeStatusField) {
                          try {
                            const option = mergeStatusField.options?.find(o => o.name === mergeStatus);
                            if (option) {
                              await github.graphql(\`` + `
                                mutation($` + `projectId: ID!, $` + `itemId: ID!, $` + `fieldId: ID!, $` + `optionId: String!) {
                                  updateProjectV2ItemFieldValue(input: {
                                    projectId: $` + `projectId, itemId: $` + `itemId, fieldId: $` + `fieldId, value: { singleSelectOptionId: $` + `optionId }
                                  }) { projectV2Item { id } }
                                }\`` + `, { projectId: projectId, itemId: itemId, fieldId: mergeStatusField.id, optionId: option.id });
                              console.log('‚úÖ Merge Status: ' + mergeStatus);
                            }
                          } catch (e) { console.log('‚ö†Ô∏è Status failed'); }
                        }
                        
                        console.log('\\\\n--- Checking Merge ---');
                        const hasRelease = releaseNotes && !releaseNotes.startsWith('<!--') && releaseNotes.length > 0;
                        const hasDeploy = deployNotes && !deployNotes.startsWith('<!--') && deployNotes.length > 0;
                        
                        if (!hasRelease || !hasDeploy) {
                          console.log('‚ùå Cannot merge');
                          const missing = [];
                          if (!hasRelease) missing.push('‚ùå Release notes');
                          if (!hasDeploy) missing.push('‚ùå Deployment notes');
                          const commentBody = '## ‚è≥ Merge Checklist\\n\\n**Required:**\\n' + missing.join('\\n');
                          const comments = await github.rest.issues.listComments({
                            owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number
                          });
                          const botComment = comments.data.find(c => c.user.type === 'Bot' && c.body.includes('Merge Checklist'));
                          if (botComment) {
                            await github.rest.issues.updateComment({
                              owner: context.repo.owner, repo: context.repo.repo, comment_id: botComment.id, body: commentBody
                            });
                          } else {
                            await github.rest.issues.createComment({
                              owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: commentBody
                            });
                          }
                          return;
                        }
                        
                        console.log('\\\\n--- Merging ---');
                        try {
                          let msg = 'Release Notes:\\n' + releaseNotes + '\\n\\nDeployment Notes:\\n' + deployNotes;
                          if (dependencies) msg += '\\n\\nDependencies:\\n' + dependencies;
                          await github.rest.pulls.merge({
                            owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number,
                            merge_method: 'squash', commit_title: pr.title + ' (#' + pr.number + ')', commit_message: msg
                          });
                          console.log('‚úÖ Merged!');
                          await github.rest.issues.createComment({
                            owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number,
                            body: '## ‚úÖ Auto-Merged!\\n\\nAll checks passed.'
                          });
                        } catch (e) {
                          console.error('‚ùå Merge failed: ' + e.message);
                          await github.rest.issues.createComment({
                            owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number,
                            body: '‚ùå Auto-merge failed: ' + e.message
                          });
                        }
            `;

            const repos = await github.paginate(github.rest.repos.listForOrg, {
              org: org, per_page: 100
            });
            
            console.log(`Found ${repos.length} repositories`);
            console.log('---\n');
            
            let successCount = 0, failCount = 0, skippedCount = 0;
            
            for (const repo of repos) {
              if (skipRepos.includes(repo.name)) {
                console.log(`‚è≠Ô∏è  ${repo.name}`);
                skippedCount++;
                continue;
              }
              
              console.log(`Processing: ${repo.name}`);
              const path = '.github/workflows/pr-to-project.yml';
              let sha = null;
              
              try {
                const existing = await github.rest.repos.getContent({
                  owner: org, repo: repo.name, path: path, ref: repo.default_branch
                });
                sha = existing.data.sha;
                console.log(`  Updating...`);
              } catch (e) {
                if (e.status === 404) console.log(`  Creating...`);
              }
              
              try {
                const params = {
                  owner: org, repo: repo.name, path: path,
                  message: 'Update: PR workflow [skip ci]',
                  content: Buffer.from(workflowContent).toString('base64'),
                  branch: repo.default_branch
                };
                if (sha) params.sha = sha;
                
                await github.rest.repos.createOrUpdateFileContents(params);
                console.log(`  ‚úÖ\n`);
                successCount++;
              } catch (e) {
                console.log(`  ‚ùå ${e.message}\n`);
                failCount++;
              }
            }
            
            console.log('\nüìä Summary:');
            console.log(`   ‚úÖ Success: ${successCount}`);
            console.log(`   ‚ùå Failed: ${failCount}`);
            console.log(`   ‚è≠Ô∏è  Skipped: ${skippedCount}`);
